// Code generated by protoc-gen-go.
// source: client_conf.proto
// DO NOT EDIT!

/*
Package tapdance is a generated protocol buffer package.

It is generated from these files:
	client_conf.proto

It has these top-level messages:
	PubKey
	TLSDecoySpec
	ClientConf
	DecoysUpdate
	StationToClient
	ClientToStation
*/
package tapdance

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type KeyType int32

const (
	KeyType_AES_GCM_128 KeyType = 90
	KeyType_AES_GCM_256 KeyType = 91
)

var KeyType_name = map[int32]string{
	90: "AES_GCM_128",
	91: "AES_GCM_256",
}
var KeyType_value = map[string]int32{
	"AES_GCM_128": 90,
	"AES_GCM_256": 91,
}

func (x KeyType) Enum() *KeyType {
	p := new(KeyType)
	*p = x
	return p
}
func (x KeyType) String() string {
	return proto.EnumName(KeyType_name, int32(x))
}
func (x *KeyType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(KeyType_value, data, "KeyType")
	if err != nil {
		return err
	}
	*x = KeyType(value)
	return nil
}
func (KeyType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// State transitions of the client
type C2S_Transition int32

const (
	C2S_Transition_C2S_NO_CHANGE C2S_Transition = 0
	// C2S_SESSION_INIT = 1; // Currently MSG_INIT is NOT protobuf
	C2S_Transition_C2S_EXPECT_RECONNECT C2S_Transition = 2
	C2S_Transition_C2S_SESSION_CLOSE    C2S_Transition = 3
	C2S_Transition_C2S_ERROR            C2S_Transition = 255
)

var C2S_Transition_name = map[int32]string{
	0:   "C2S_NO_CHANGE",
	2:   "C2S_EXPECT_RECONNECT",
	3:   "C2S_SESSION_CLOSE",
	255: "C2S_ERROR",
}
var C2S_Transition_value = map[string]int32{
	"C2S_NO_CHANGE":        0,
	"C2S_EXPECT_RECONNECT": 2,
	"C2S_SESSION_CLOSE":    3,
	"C2S_ERROR":            255,
}

func (x C2S_Transition) Enum() *C2S_Transition {
	p := new(C2S_Transition)
	*p = x
	return p
}
func (x C2S_Transition) String() string {
	return proto.EnumName(C2S_Transition_name, int32(x))
}
func (x *C2S_Transition) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(C2S_Transition_value, data, "C2S_Transition")
	if err != nil {
		return err
	}
	*x = C2S_Transition(value)
	return nil
}
func (C2S_Transition) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// State transitions of the server
type S2C_Transition int32

const (
	S2C_Transition_S2C_NO_CHANGE         S2C_Transition = 0
	S2C_Transition_S2C_SESSION_INIT      S2C_Transition = 1
	S2C_Transition_S2C_CONFIRM_RECONNECT S2C_Transition = 2
	S2C_Transition_S2C_SESSION_CLOSE     S2C_Transition = 3
	// TODO should probably also allow EXPECT_RECONNECT here, for DittoTap
	S2C_Transition_S2C_ERROR S2C_Transition = 255
)

var S2C_Transition_name = map[int32]string{
	0:   "S2C_NO_CHANGE",
	1:   "S2C_SESSION_INIT",
	2:   "S2C_CONFIRM_RECONNECT",
	3:   "S2C_SESSION_CLOSE",
	255: "S2C_ERROR",
}
var S2C_Transition_value = map[string]int32{
	"S2C_NO_CHANGE":         0,
	"S2C_SESSION_INIT":      1,
	"S2C_CONFIRM_RECONNECT": 2,
	"S2C_SESSION_CLOSE":     3,
	"S2C_ERROR":             255,
}

func (x S2C_Transition) Enum() *S2C_Transition {
	p := new(S2C_Transition)
	*p = x
	return p
}
func (x S2C_Transition) String() string {
	return proto.EnumName(S2C_Transition_name, int32(x))
}
func (x *S2C_Transition) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(S2C_Transition_value, data, "S2C_Transition")
	if err != nil {
		return err
	}
	*x = S2C_Transition(value)
	return nil
}
func (S2C_Transition) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type PubKey struct {
	// A public key, as used by the station.
	Key              []byte   `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Type             *KeyType `protobuf:"varint,2,opt,name=type,enum=tapdance.KeyType" json:"type,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *PubKey) Reset()                    { *m = PubKey{} }
func (m *PubKey) String() string            { return proto.CompactTextString(m) }
func (*PubKey) ProtoMessage()               {}
func (*PubKey) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *PubKey) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *PubKey) GetType() KeyType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return KeyType_AES_GCM_128
}

type TLSDecoySpec struct {
	// The hostname/SNI to use for this host
	//
	// The hostname is the only required field, although other
	// fields are expected to be present in most cases.
	Hostname *string `protobuf:"bytes,1,opt,name=hostname" json:"hostname,omitempty"`
	// The 32-bit ipv4 address, in network byte order
	//
	// If the IPv4 address is absent, then it may be resolved via
	// DNS by the client, or the client may discard this decoy spec
	// if local DNS is untrusted, or the service may be multihomed.
	Ipv4Addr *uint32 `protobuf:"fixed32,2,opt,name=ipv4addr" json:"ipv4addr,omitempty"`
	// The Tapdance station public key to use when contacting this
	// decoy
	//
	// If omitted, the default station public key (if any) is used.
	Pubkey *PubKey `protobuf:"bytes,3,opt,name=pubkey" json:"pubkey,omitempty"`
	// The maximum duration, in milliseconds, to maintain an open
	// connection to this decoy (because the decoy may close the
	// connection itself after this length of time)
	//
	// If omitted, a default of 30,000 milliseconds is assumed.
	Timeout *uint32 `protobuf:"varint,4,opt,name=timeout" json:"timeout,omitempty"`
	// The maximum TCP window size to attempt to use for this decoy.
	//
	// If omitted, a default of 15360 is assumed.
	//
	// TODO: the default is based on the current heuristic of only
	// using decoys that permit windows of 15KB or larger.  If this
	// heuristic changes, then this default doesn't make sense.
	Tcpwin           *uint32 `protobuf:"varint,5,opt,name=tcpwin" json:"tcpwin,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TLSDecoySpec) Reset()                    { *m = TLSDecoySpec{} }
func (m *TLSDecoySpec) String() string            { return proto.CompactTextString(m) }
func (*TLSDecoySpec) ProtoMessage()               {}
func (*TLSDecoySpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *TLSDecoySpec) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

func (m *TLSDecoySpec) GetIpv4Addr() uint32 {
	if m != nil && m.Ipv4Addr != nil {
		return *m.Ipv4Addr
	}
	return 0
}

func (m *TLSDecoySpec) GetPubkey() *PubKey {
	if m != nil {
		return m.Pubkey
	}
	return nil
}

func (m *TLSDecoySpec) GetTimeout() uint32 {
	if m != nil && m.Timeout != nil {
		return *m.Timeout
	}
	return 0
}

func (m *TLSDecoySpec) GetTcpwin() uint32 {
	if m != nil && m.Tcpwin != nil {
		return *m.Tcpwin
	}
	return 0
}

type ClientConf struct {
	DecoyList        *DecoysUpdate `protobuf:"bytes,1,opt,name=decoy_list" json:"decoy_list,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *ClientConf) Reset()                    { *m = ClientConf{} }
func (m *ClientConf) String() string            { return proto.CompactTextString(m) }
func (*ClientConf) ProtoMessage()               {}
func (*ClientConf) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ClientConf) GetDecoyList() *DecoysUpdate {
	if m != nil {
		return m.DecoyList
	}
	return nil
}

type DecoysUpdate struct {
	Generation       *uint32         `protobuf:"varint,1,opt,name=generation" json:"generation,omitempty"`
	DefaultPubkey    *PubKey         `protobuf:"bytes,2,opt,name=default_pubkey" json:"default_pubkey,omitempty"`
	TlsDecoys        []*TLSDecoySpec `protobuf:"bytes,3,rep,name=tls_decoys" json:"tls_decoys,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *DecoysUpdate) Reset()                    { *m = DecoysUpdate{} }
func (m *DecoysUpdate) String() string            { return proto.CompactTextString(m) }
func (*DecoysUpdate) ProtoMessage()               {}
func (*DecoysUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *DecoysUpdate) GetGeneration() uint32 {
	if m != nil && m.Generation != nil {
		return *m.Generation
	}
	return 0
}

func (m *DecoysUpdate) GetDefaultPubkey() *PubKey {
	if m != nil {
		return m.DefaultPubkey
	}
	return nil
}

func (m *DecoysUpdate) GetTlsDecoys() []*TLSDecoySpec {
	if m != nil {
		return m.TlsDecoys
	}
	return nil
}

type StationToClient struct {
	// Should accompany (at least) SESSION_INIT and CONFIRM_RECONNECT.
	ProtocolVersion *uint32 `protobuf:"varint,1,opt,name=protocol_version" json:"protocol_version,omitempty"`
	// There might be a state transition. May be absent; absence should be
	// treated identically to NO_CHANGE.
	StateTransition *S2C_Transition `protobuf:"varint,2,opt,name=state_transition,enum=tapdance.S2C_Transition" json:"state_transition,omitempty"`
	// The station can send client config info piggybacked
	// on any message, as it sees fit
	ConfigInfo *ClientConf `protobuf:"bytes,3,opt,name=config_info" json:"config_info,omitempty"`
	// Random-sized junk to defeat packet size fingerprinting.
	Padding          []byte `protobuf:"bytes,100,opt,name=padding" json:"padding,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *StationToClient) Reset()                    { *m = StationToClient{} }
func (m *StationToClient) String() string            { return proto.CompactTextString(m) }
func (*StationToClient) ProtoMessage()               {}
func (*StationToClient) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *StationToClient) GetProtocolVersion() uint32 {
	if m != nil && m.ProtocolVersion != nil {
		return *m.ProtocolVersion
	}
	return 0
}

func (m *StationToClient) GetStateTransition() S2C_Transition {
	if m != nil && m.StateTransition != nil {
		return *m.StateTransition
	}
	return S2C_Transition_S2C_NO_CHANGE
}

func (m *StationToClient) GetConfigInfo() *ClientConf {
	if m != nil {
		return m.ConfigInfo
	}
	return nil
}

func (m *StationToClient) GetPadding() []byte {
	if m != nil {
		return m.Padding
	}
	return nil
}

type ClientToStation struct {
	ProtocolVersion *uint32 `protobuf:"varint,1,opt,name=protocol_version" json:"protocol_version,omitempty"`
	// The client reports its decoy list's version number here, which the
	// station can use to decide whether to send an updated one. The station
	// should always send a list if this field is set to 0.
	DecoyListGeneration *uint32         `protobuf:"varint,2,opt,name=decoy_list_generation" json:"decoy_list_generation,omitempty"`
	StateTransition     *C2S_Transition `protobuf:"varint,3,opt,name=state_transition,enum=tapdance.C2S_Transition" json:"state_transition,omitempty"`
	// Random-sized junk to defeat packet size fingerprinting.
	Padding          []byte `protobuf:"bytes,100,opt,name=padding" json:"padding,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ClientToStation) Reset()                    { *m = ClientToStation{} }
func (m *ClientToStation) String() string            { return proto.CompactTextString(m) }
func (*ClientToStation) ProtoMessage()               {}
func (*ClientToStation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ClientToStation) GetProtocolVersion() uint32 {
	if m != nil && m.ProtocolVersion != nil {
		return *m.ProtocolVersion
	}
	return 0
}

func (m *ClientToStation) GetDecoyListGeneration() uint32 {
	if m != nil && m.DecoyListGeneration != nil {
		return *m.DecoyListGeneration
	}
	return 0
}

func (m *ClientToStation) GetStateTransition() C2S_Transition {
	if m != nil && m.StateTransition != nil {
		return *m.StateTransition
	}
	return C2S_Transition_C2S_NO_CHANGE
}

func (m *ClientToStation) GetPadding() []byte {
	if m != nil {
		return m.Padding
	}
	return nil
}

func init() {
	proto.RegisterType((*PubKey)(nil), "tapdance.PubKey")
	proto.RegisterType((*TLSDecoySpec)(nil), "tapdance.TLSDecoySpec")
	proto.RegisterType((*ClientConf)(nil), "tapdance.ClientConf")
	proto.RegisterType((*DecoysUpdate)(nil), "tapdance.DecoysUpdate")
	proto.RegisterType((*StationToClient)(nil), "tapdance.StationToClient")
	proto.RegisterType((*ClientToStation)(nil), "tapdance.ClientToStation")
	proto.RegisterEnum("tapdance.KeyType", KeyType_name, KeyType_value)
	proto.RegisterEnum("tapdance.C2S_Transition", C2S_Transition_name, C2S_Transition_value)
	proto.RegisterEnum("tapdance.S2C_Transition", S2C_Transition_name, S2C_Transition_value)
}

func init() { proto.RegisterFile("client_conf.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 533 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x7c, 0x92, 0xd1, 0x6e, 0xd3, 0x30,
	0x18, 0x85, 0x49, 0x33, 0xd6, 0xed, 0xef, 0x9a, 0xba, 0x56, 0x8b, 0xc2, 0x05, 0x22, 0xca, 0x55,
	0x29, 0x52, 0x25, 0x22, 0x98, 0x76, 0x3b, 0x99, 0x30, 0xaa, 0x6d, 0xc9, 0xd4, 0x04, 0x09, 0xc1,
	0x85, 0x95, 0x25, 0x6e, 0x89, 0xe8, 0xec, 0xa8, 0x71, 0x07, 0x11, 0x0f, 0xc1, 0x03, 0xf0, 0xb0,
	0x20, 0xbb, 0x2d, 0x09, 0x95, 0xc6, 0xa5, 0x8f, 0xfd, 0x9f, 0xf3, 0xe5, 0xfc, 0x81, 0x7e, 0xba,
	0xcc, 0x19, 0x97, 0x34, 0x15, 0x7c, 0x3e, 0x29, 0x56, 0x42, 0x0a, 0x7c, 0x24, 0x93, 0x22, 0x4b,
	0x78, 0xca, 0xdc, 0x53, 0x38, 0xbc, 0x59, 0xdf, 0x5e, 0xb2, 0x0a, 0x77, 0xc0, 0xfc, 0xca, 0x2a,
	0xdb, 0x70, 0x8c, 0xd1, 0x09, 0x7e, 0x0e, 0x07, 0xb2, 0x2a, 0x98, 0xdd, 0x72, 0x8c, 0x91, 0xe5,
	0xf5, 0x27, 0xbb, 0xf7, 0x93, 0x4b, 0x56, 0xc5, 0x55, 0xc1, 0xdc, 0x35, 0x9c, 0xc4, 0x57, 0xd1,
	0x5b, 0x96, 0x8a, 0x2a, 0x2a, 0x58, 0x8a, 0x11, 0x1c, 0x7d, 0x11, 0xa5, 0xe4, 0xc9, 0x1d, 0xd3,
	0x16, 0xc7, 0x4a, 0xc9, 0x8b, 0xfb, 0xd7, 0x49, 0x96, 0xad, 0xb4, 0x4d, 0x1b, 0x3b, 0x70, 0x58,
	0xac, 0x6f, 0x55, 0x88, 0xe9, 0x18, 0xa3, 0x8e, 0x87, 0x6a, 0xdb, 0x2d, 0x43, 0x0f, 0xda, 0x32,
	0xbf, 0x63, 0x62, 0x2d, 0xed, 0x03, 0xc7, 0x18, 0x75, 0xb1, 0x05, 0x87, 0x32, 0x2d, 0xbe, 0xe5,
	0xdc, 0x7e, 0xac, 0xce, 0xee, 0x19, 0x00, 0xd1, 0x5f, 0x43, 0x04, 0x9f, 0xe3, 0x31, 0x40, 0xa6,
	0x08, 0xe8, 0x32, 0x2f, 0xa5, 0x8e, 0xed, 0x78, 0x4f, 0x6a, 0x53, 0x4d, 0x57, 0x7e, 0x28, 0xb2,
	0x44, 0x32, 0xf7, 0x3b, 0x9c, 0x34, 0xcf, 0x18, 0x03, 0x2c, 0x18, 0x67, 0xab, 0x44, 0xe6, 0x82,
	0xeb, 0xd9, 0x2e, 0x1e, 0x81, 0x95, 0xb1, 0x79, 0xb2, 0x5e, 0x4a, 0xba, 0x05, 0x6d, 0x3d, 0x00,
	0x3a, 0x06, 0x90, 0xcb, 0x92, 0xea, 0xf4, 0xd2, 0x36, 0x1d, 0xf3, 0xdf, 0xe4, 0x66, 0x35, 0xee,
	0x2f, 0x03, 0x7a, 0x91, 0xd4, 0x39, 0xb1, 0xd8, 0xd0, 0x63, 0x1b, 0x90, 0xde, 0x44, 0x2a, 0x96,
	0xf4, 0x9e, 0xad, 0xca, 0x9a, 0xc1, 0x03, 0x54, 0xca, 0x44, 0x32, 0x2a, 0x57, 0x09, 0x2f, 0x73,
	0x4d, 0xb7, 0xd9, 0x82, 0x5d, 0xfb, 0x47, 0x1e, 0xa1, 0xf1, 0xdf, 0x7b, 0xfc, 0x02, 0x3a, 0x6a,
	0xb9, 0xf9, 0x82, 0xe6, 0x7c, 0x2e, 0xb6, 0xed, 0x0e, 0xea, 0xe7, 0x8d, 0xca, 0x7a, 0xd0, 0x2e,
	0x92, 0x2c, 0xcb, 0xf9, 0xc2, 0xce, 0xd4, 0xa6, 0xdd, 0x9f, 0x06, 0xf4, 0x36, 0xf7, 0xb1, 0xd8,
	0x52, 0xfe, 0x87, 0xee, 0x19, 0x0c, 0xeb, 0xc6, 0x69, 0xa3, 0xc0, 0xd6, 0x83, 0xf0, 0xe6, 0x3e,
	0x3c, 0xf1, 0xa2, 0x26, 0xfc, 0x3e, 0xd1, 0xf8, 0x25, 0xb4, 0xb7, 0x7f, 0x19, 0xee, 0x41, 0xe7,
	0xdc, 0x8f, 0xe8, 0x05, 0xb9, 0xa6, 0xaf, 0xbc, 0x33, 0xf4, 0xa9, 0x29, 0x78, 0x6f, 0x4e, 0xd1,
	0xe7, 0x71, 0x06, 0xd6, 0x9e, 0x5f, 0x1f, 0xba, 0x4a, 0x09, 0x42, 0x4a, 0xde, 0x9f, 0x07, 0x17,
	0x3e, 0x7a, 0x84, 0x6d, 0x18, 0x28, 0xc9, 0xff, 0x78, 0xe3, 0x93, 0x98, 0xce, 0x7c, 0x12, 0x06,
	0x81, 0x4f, 0x62, 0xd4, 0xc2, 0x43, 0xe8, 0xab, 0x9b, 0xc8, 0x8f, 0xa2, 0x69, 0x18, 0x50, 0x72,
	0x15, 0x46, 0x3e, 0x32, 0xb1, 0x05, 0xc7, 0x7a, 0x60, 0x36, 0x0b, 0x67, 0xe8, 0xb7, 0x31, 0xfe,
	0x01, 0xd6, 0x5e, 0xe5, 0x7d, 0xe8, 0x2a, 0xa5, 0x99, 0x32, 0x00, 0xa4, 0xa4, 0x9d, 0xd7, 0x34,
	0x98, 0xc6, 0xc8, 0xc0, 0x4f, 0x61, 0xa8, 0x54, 0x12, 0x06, 0xef, 0xa6, 0xb3, 0xeb, 0xfd, 0xf0,
	0xe6, 0x40, 0x23, 0x5c, 0xc9, 0xbb, 0xf0, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x7d, 0x8b, 0x22,
	0x69, 0xc0, 0x03, 0x00, 0x00,
}
